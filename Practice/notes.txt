** an interpreter in the browser reads over the JavaScript code, interprets each 
   line, and runs it.
   
** JS -> inline
-> After body part(it's easy to load page from browser), use <script></script>

** to write down in console in browser
-> console.log('');

** JS -> external
-> create xyz.js file and write JS code there and in html file, write 
   <script src="xyz.js></script>

** JS 
-> lightweight(doesn't need much memory of computer and relatively simple syntax), 
   cross-platform (used in multiple platforms) object oriented (JS based on object).

** Three core languages in web development : HTML(for content like text, images, 
   etc..), CSS(presentation, styling), JS (dynamic effects, programming)

** JS in client-side : traditionally used in browser. To make pages attractive, 
   dynamic effects, interactivity,modern web application

** JS in server side : NodeJS.

** JS version: ES5,ES6(2015),ES7(2016), ES8(2017)

** ';' is not important

** case sensitive

** 5 Data-types - JS has dynamic typing (datatypes automatically assigned to variables)
1) Number : float, decimal, integer
2) String : sequence of chars, used for text
3) Boolean : Logical data-type, true or false
4) Undefined : Varible that doesn't have a value yet
5) Null : non-existent
** use Camel words in JS 
** can't start variable names with numbers or symbols except $ and _
** can't use reserved js words as a variableName

** comments -> '//' one line comment, '/* */' multi line comments

** Oprtator Precedence
-> ()  >  !..,++..,--..(right to left)  >  **(right to left)  >  *,/,%  >  +,-  >
  <<,>>,<<<  >  <,<=,>,>=,instanceof  >  ==,!=  >  &  >  ^  >  |  >  &&  >  ||  >
  ..?..:..(right to left)  >  =,+=,-=,**=,*=,/=,etc..(right to left)  >  

  ** Boolean Logic 
  -> AND && => true if all are true
  -> OR || => rue if one is true
  -> NOT ! => inverts true/false value

  ** Falsy values: Undefined,null,0,'',NaN
  ** Truthy values: NOT falsy values
  ** == -> values must be same
  -> eg. : 23 == '23' => 'true'
  ** === -> values and datatypes must be same 
  -> eg. : 23 === '23' => false
  
  ** functions are for reuse block of code

  ** Arrays are collection of objects/values of same/different datatypes

  ** Variable mutation means u can change the value of variable

  ** Type conversion means JS can automatically change the type of variable 
     like console.log(str+number)

  ** var declarations are globally scoped or function scoped while let and const 
     are block scoped. var variables can be updated and re-declared within its 
     scope; let variables can be updated but not re-declared; const variables can 
     neither be updated nor re-declared. They are all hoisted to the top of their 
     scope.

  ** Execution of JS
  -> our code ->(JavaScript Engine) parser(if there is any syntax error,it will 
     return to the code,won't go ahead) -(Abstract Syntax Tree)->Conversion to 
     machine code -(Machine code)-> Code runs

  ** Execution context 
  -> A container that store variables and a piece of code that is evaluated or executed.

  ** Global Execution context
  -> code that is not inside the function..associated with global object. If u 
     write globalproperty then it will automatically become property of window 
     object.
     ex. name === window.name //true
     To know more watch the video (12-01-2021)

  ** Execution context object
  -> Variable object
  -> Scope chain 
  -> This variable
  And also it has 2 phases
  -> Creation Phase
  -> Execution phase

  1) Variable object:
  -> Argument object is created which contains all the argument that are passed in 
     the functions.
  -> Code scanned for FUNCTION DECLARATION, property is created for each function, 
     pointing to the function. (Hoisting)
  -> code scanned for VARIABLE DECLARATION, propert is created for each variable 
     and set to Undefined. (Hoisting)

  ** Hoisting
  -> functions or variables are available before the execution phase starts.
     hoisting doesn't support const values.
     Ex. function fn(year){
            console.log(2020-year)
         }
         fn(2000)
         -> here 1st we define the function then we call(declare) it but if 1st we 
            call the function and in next line if we define it then, calling the 
            function is stored in variable object means function is not executed 
            yet but it is hoisted. It only works for function declarations,not for 
            function expression.

     Ex. fn(year)
         var fn = function(year) {
            console.log(2020-year)
         }
         -> it will give error. fn(year) is not going to store in variable object or
            it is not hoisted. so it will give error that there is no 'fn' function.

     Ex. console.log(age) //output : undefined
         age = 20
         console.log(age) //output: 20
         -> it won't give error, bcz age is stored in variable object, it's hoisted 
            and set to undefined. and when it defines, it will update the value from
            undefined to value.
      
     Ex. console.log(age)
     ->  it will give error that there is no age defined.

     Ex. console.log(age) //output : undefined
         age = 20 //it's stored in variable object of global executed context

         function foo(){
            console.log(age) //output: undefined
            var age = 32 //it's stored in variable object of execution context of foo function
            console.log(age) //output: 32
         }
         console.log(age) //output: 20
         -> these two variables (age) are not same.
         
  ** Scope chain
  -> Each new function creates scope, in which variables it defines are accessible.
  -> Lexical scoping: a function that is laxically within another function gets 
     access to the scope of the outer function. 
   Ex. var a ="hello"  //---------------------------->global scope        ^
       first();        //---------------------------->global scope        |
       function first(){                                                  |
          var b="hi"   //---------------------------->1st scope           |scope
          second();    //---------------------------->1st scope           |chain
          function second(){                                              |
             var c="hey" //-------------------------->2nd scope           |
             console.log(a+b+c)//hellohihey //------->2nd scope           |
          }
       }

  ** This keyword
  -> Regular function call : this keyword points at the global object,(window object
     in browser).
  -> Method call : this variable points the object that is callig the method.
  -> This keyword is not assigned a value until a function where it's defined is 
     actually called.
  Ex. console.log(this) //output: Window
      age(2000)
      function age(year){
         console.log(2020-year); //20
         console.log(this)       //Window //bcz this function is attached to window object
      }

  ** Object and Properties
  -> object-> key-value pair
     array ->orders matter a lot
     object -> order doesn't matter

  ** History
  -> 1996: Changed name from Livescript to JavaScript to attract java developers
  -> 1997: ES1 (ECMAScript1) - 1st version of JS standard
     ECMAScript: the language standard
  -> 2009: ES5 with new features -> fully supported in all browsers-> JS fundamentals,how language works,DOM manipulation,...
  -> 2015: ES6/ES2015 - the biggest update ever -> well supported in modern browsers, not supported in old browsers.but can convert ES6 to ES5 -> Async JS, AJXand API calls, Webpack & Babel,...
  -> 2015: changed to annual release cycle
  -> 2016,2017,2018,...->ES7,ES8,...

  ** DOM -> Document Object Model - structured representation of HTML document.
  -> It is used to connect webpages to scripts like JS.
  -> For each HTML box,there is an object in the DOM that we can access and interact with.
  -> JS and DOM are different.

  ** HTML
  -> id attribute should be unique but class attribute can be written many times.
  
  ** Events
  -> Notifications that are sent to notify the code that something happened on the 
     webpage.
  ** Event Listener
  -> A function that performs an action based on a certain event. It waits for a 
     specific event to happen.

  ** Message Queue
  -> where all messages are put.

  ** callback function
  -> a function that we pass as an argument in another function is called callback 
     function.
  
  ** Anonymous function
  -> we don't use function name, just directly write the function.

  ** Pollifilling
  -> modern method 

  ** transfilling
  -> 

  ** Browser Local storage
  -> there is key-value pair and value will be converted to string automatically. 
     Key will be unique. Site vise and window (not os) vise local storage will be 
     different. JSON data is stored. The data will be there until u don't delete it 
     manually.
  -> Syntax
      window.localStorage
  -> Syntax for SAVING data to localStorage:
      localStorage.setItem("key", "value");
  -> Syntax for READING data from localStorage:
      var lastname = localStorage.getItem("key");
  -> Syntax for REMOVING data from localStorage:
      localStorage.removeItem("key");
  -> Technical Details
      Return Value:	A Storage object

  ** session storage
  -> tab vise session data will be different. session data is good rather than 
     local storage data bcz when tab is closed, the data will be gone. JSON data
     is stored. Data will expire after closing the tab.
  -> Syntax:
      window.sessionStorage
  -> Syntax for SAVING data to sessionStorage:
      sessionStorage.setItem("key", "value");
  -> Syntax for READING data from sessionStorage:
      var lastname = sessionStorage.getItem("key");
  -> Syntax for REMOVING saved data from sessionStorage:
      sessionStorage.removeItem("key");
  -> Syntax for REMOVING ALL saved data from sessionStorage:
      sessionStorage.clear();
  -> Technical Details
         Return Value:	A Storage object

  ** cookie data 
  -> only values are stored in cookies and it has very small storage.

  ** Primitive Datatypes:
  -> Numbers, Strings, Booleans, Undefined, Null

  ** Non-Premitive: (reference type)
  -> Arrays, Functions, Objects, Dates, Wrappersfor numbers, Strings, Booleans are 
     Objects.

  ** Object Oriented programming:
  -> Objects interavting with one another through methods and Properties.
  -> Used to store data, structure applications into modules and keeping code clean.

  ** Every JS object has a prototype property which makes inheritance possible in JS.

  ** The prototype property of an object is where we put methods and properties that 
     we want other objects to inherit.

  ** The constructor's prototype property is NOT the prototype of the constructor 
     itself., it's the prototype of ALL instances that are created through it:

  ** When a certain method (or property) is called, the search starts in the object 
     itself, and if it cannot found, the search moves on to the object's prototype.
     This continues until the method is found: Prototype chain.

  ** Functions are also objects
  -> A function is an instance of object type
  -> A function behaves like any other object.
  -> We can pass a function as an argument to another function
  -> We can return a function from a function

  ** Clausers 
  -> An inner function has always access to the variables and parameters of its
     outer function, even after the outer function has returned.
     
  ** Generic fuction

  ** ES6/ES2015 